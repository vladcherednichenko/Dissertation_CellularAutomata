'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var parsePackChunk = function parsePackChunk(data) {
  return {
    numModels: data.nextInt()
  };
};

var parseSizeChunk = function parseSizeChunk(data) {
  return data.nextPattern(['x', 'y', 'z'], 4);
};

var parseXYZIChunk = function parseXYZIChunk(data) {
  var numVoxels = data.nextInt();
  var voxels = [];
  for (var i = 0; i < numVoxels; i++) {
    voxels.push(data.nextPattern(['x', 'y', 'z', 'i'], 1));
  }
  return { numVoxels: numVoxels, voxels: voxels };
};

var parseRGBAChunk = function parseRGBAChunk(data) {
  var palette = [];
  for (var i = 0; i < 256; i++) {
    palette.push(data.nextPattern(['r', 'g', 'b', 'a'], 1));
  }
  return { palette: palette };
};

var MATERIAL_TYPE = ['diffuse', 'metal', 'glass', 'emissive'];

var parseMattChunk = function parseMattChunk(data) {
  var id = data.nextInt();
  var materialType = data.nextInt();
  var materialWeight = data.nextFloat();
  var propertyBits = data.nextInt();
  var propertyFlags = [(propertyBits & 1) > 0 && 'plastic', (propertyBits & 2) > 0 && 'roughness', (propertyBits & 4) > 0 && 'specular', (propertyBits & 8) > 0 && 'ior', (propertyBits & 16) > 0 && 'attenuation', (propertyBits & 32) > 0 && 'power', (propertyBits & 64) > 0 && 'glow', (propertyBits & 128) > 0 && 'isTotalPower'];
  var properties = propertyFlags.filter(Boolean).map(function (property) {
    return {
      property: property,
      value: property !== 'isTotalPower' ? data.nextFloat() : null
    };
  });

  return {
    id: id,
    materialType: MATERIAL_TYPE[materialType],
    materialWeight: materialWeight,
    properties: properties
  };
};

var PARSERS = {
  PACK: parsePackChunk,
  SIZE: parseSizeChunk,
  XYZI: parseXYZIChunk,
  RGBA: parseRGBAChunk,
  MATT: parseMattChunk
};

var dataFactory = function dataFactory(buffer) {
  var data = new DataView(buffer);
  var offset = 0;

  return {
    hasNext: function hasNext() {
      return offset < data.byteLength;
    },
    nextString: function nextString() {
      var str = '';
      for (var i = 0; i < 4; i++) {
        str += String.fromCharCode(data.getUint8(offset, true));
        offset += 1;
      }
      return str;
    },
    nextInt: function nextInt() {
      var int = data.getUint32(offset, true);
      offset += 4;
      return int;
    },
    nextFloat: function nextFloat() {
      var float = data.getFloat32(offset, true);
      offset += 4;
      return float;
    },
    nextPattern: function nextPattern(pattern, bytes) {
      return pattern.reduce(function (obj, key) {
        obj[key] = data['getUint' + bytes * 8](offset, true);
        offset += bytes;
        return obj;
      }, {});
    }
  };
};

var readHead = function readHead(data) {
  return {
    id: data.nextString(),
    version: data.nextInt()
  };
};

var readBasicChunkData = function readBasicChunkData(data) {
  return {
    id: data.nextString(),
    numContent: data.nextInt(),
    numChildren: data.nextInt()
  };
};

var readChunk = function readChunk(data) {
  var chunk = readBasicChunkData(data);
  var parser = PARSERS[chunk.id];
  if (typeof parser === 'function') {
    return Object.assign(chunk, {
      content: parser(data)
    });
  } else {
    throw new Error('Unrecognized chunk id: \'' + chunk.id + '\'');
  }
};

var readBody = function readBody(data) {
  var body = [];
  while (data.hasNext()) {
    var chunk = readChunk(data);
    body.push(chunk);
  }
  return body;
};

var parse = function parse(buffer) {
  var data = dataFactory(buffer);

  var head = readHead(data);
  if (head.id !== 'VOX ') {
    throw new Error('Expected file id \'VOX \', found: \'' + head.id + '\'');
  }

  var mainChunk = readBasicChunkData(data);
  if (mainChunk.id !== 'MAIN') {
    throw new Error('Expected \'MAIN\' chunk, found: \'' + mainChunk.id + '\'');
  }

  return {
    id: head.id,
    version: head.version,
    body: Object.assign(mainChunk, {
      children: readBody(data)
    })
  };
};

exports.parse = parse;
